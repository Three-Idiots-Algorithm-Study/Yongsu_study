## 합병정렬
[코드](https://github.com/KANGYONGSU23/CodingTest/blob/main/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4/1/42748.%E2%80%85K%EB%B2%88%EC%A7%B8%EC%88%98/%ED%95%A9%EB%B3%91%EC%A0%95%EB%A0%AC.js)

<aside>
💡 합병 정렬 또는 병합 정렬은 O(n log n) 비교 기반 정렬 알고리즘이다

</aside>

1. 배열을 나눌 수 없을 때 까지 둘로 나눈다.
2. 인접한 두 배열에서 가장 앞에 있는(가장 작은) 요소 두개를 비교하여 작은 것을 정렬된 배열에 넣는다.
3. 반복.

![image](https://github.com/Three-Idiots-Algorithm-Study/Yongsu_study/assets/101508006/bd7ff789-b0dc-4d4a-b685-fff1243ae5d7)


**장점**

> 
> 
> - 시간복잡도
>     - 배열의 요소가 **1개가 될 때 까지 분할** -> `n번 호출`
>     - 배열을 **반씩 분할** 해가며 정렬 -> `logN 만큼의 시간 소요`
>     - 즉, 최종적으로 **한 번 호출당 검색할 데이터 양이 절반**이 되므로 `O(nlogn)`의 시간복잡도를 가진다.
> - 안정적인 정렬
> - 데이터의 분포에 영향을 덜 받는다. 입력 데이터가 무엇이든 간에 **O(nlogn)** 로 동일
> - **연결 리스트(Linked List)로 구성**하면, 링크 인덱스만 변경되므로 데이터 이동은 무시될만큼 작아짐.

**단점**

> 
> 
> - 데이터가 **배열**로 구성된 경우 **추가적인 메모리 임시 배열**(buff)이 필요하다.
> - 데이터 크기가 큰 경우 이동 횟수가 많으므로 시간 낭비 발생
